<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="swift," />










<meta name="description" content="GCD技术点1.老生常谈 任务与队列">
<meta name="keywords" content="swift">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 多线程GCD封装">
<meta property="og:url" content="https://www.chuqingr.cn/2018/08/22/iOS-多线程GCD封装/index.html">
<meta property="og:site_name" content="Yshao的个人博客">
<meta property="og:description" content="GCD技术点1.老生常谈 任务与队列">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-30T04:34:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 多线程GCD封装">
<meta name="twitter:description" content="GCD技术点1.老生常谈 任务与队列">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.chuqingr.cn/2018/08/22/iOS-多线程GCD封装/"/>





  <title>iOS 多线程GCD封装 | Yshao的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/chuqingr" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yshao的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学海无涯苦作舟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.chuqingr.cn/2018/08/22/iOS-多线程GCD封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yshao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yshao的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS 多线程GCD封装</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T10:02:12+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/22/iOS-多线程GCD封装/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/22/iOS-多线程GCD封装/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="GCD技术点"><a href="#GCD技术点" class="headerlink" title="GCD技术点"></a>GCD技术点</h1><h2 id="1-老生常谈-任务与队列"><a href="#1-老生常谈-任务与队列" class="headerlink" title="1.老生常谈 任务与队列"></a>1.老生常谈 任务与队列</h2><a id="more"></a>
<ul>
<li><p>1.任务</p>
<blockquote>
<p>GCD中，任务分为同步任务（sync）和异步任务（async）两种。</p>
<p>两者的区别：异步任务具备开辟新线程的能力(只是具备这个能力，并不是所有的异步任务都会开辟新线程)，同步任务不具备开辟新线程的能力。</p>
</blockquote>
</li>
<li><p>2.队列</p>
<blockquote>
<p>队列是执行任务的容器，遵循先进先出(FIFO)的原则，GCD中队列分为串行队列和并发队列两种</p>
<p>两者的区别：并发队列可以同时执行多个任务，串行队列只能按顺序执行任务</p>
<p>另外还有两种特殊的队列：<br>全局队列：是并发队列的一种，用来执行较耗时的操作<br>主队列：是串行队列的一种，只能在主线程中进行，只有主线程空闲的时候才会被执行(刷新UI)</p>
</blockquote>
</li>
</ul>
<p>因为任务是要跟队列结合使用的，所以排列组合一下，应该是一共有八种情况(将全局队列跟主队列也当做队列)<br>如果在各个不同的队列中执行循环:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for i in 0...10 &#123;</span><br><span class="line">	queue.async &#123; /// 异步</span><br><span class="line">		print(&quot;this is NO.\(i), current thread name is \(Thread.current)&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	queue.sync &#123; /// 同步</span><br><span class="line">		print(&quot;this is NO.\(i), current thread name is \(Thread.current)&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以得出结论：</p>
</blockquote>
<ul>
<li>1.只要是串行的队列，不管是同步的还是异步的任务，得到的结果都是有序的。</li>
<li>2.只要是同步的任务，不管是串行队列还是并发队列，得到的结果都是有序的。</li>
<li>3.异步并发(全局)队列，得到的结果是无序的。</li>
<li>4.主队列的同步任务会造成死锁，程序假死</li>
</ul>
<p>有序是指:循环是从0-10依次执行。无序是指:循环不是0-10，而且随机执行。</p>
<h2 id="2-线程间通讯与服务优先级-Qos"><a href="#2-线程间通讯与服务优先级-Qos" class="headerlink" title="2.线程间通讯与服务优先级(Qos)"></a>2.线程间通讯与服务优先级(Qos)</h2><h3 id="1-线程间通讯"><a href="#1-线程间通讯" class="headerlink" title="1.线程间通讯"></a>1.线程间通讯</h3><p>在iOS开发中，UI层面的任务只能在主线程中执行，而比较耗时的任务则放到子线程中执行，如：数据请求，文件下载，上传等，很多时候需要用到线程间的通讯。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalQueue = <span class="type">DispatchQueue</span>.global() </span><br><span class="line">globalQueue.async &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>.<span class="keyword">init</span>(string: <span class="string">"http://imageUrl/****"</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> imageData = <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">				<span class="keyword">let</span> image = <span class="type">UIImage</span>(data: imageData)       </span><br><span class="line">				<span class="comment">/// 更新图片回到主线程</span></span><br><span class="line">				<span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">					<span class="keyword">self</span>.imgView.image = image</span><br><span class="line">					<span class="keyword">self</span>.imgView.sizeToFit()</span><br><span class="line">				&#125;       </span><br><span class="line">		&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(error)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-服务优先级-Qos"><a href="#2-服务优先级-Qos" class="headerlink" title="2.服务优先级(Qos)"></a>2.服务优先级(Qos)</h3><blockquote>
<p>服务优先级绝对了对一个任务分配的资源的大小，并非绝对的执行顺序。在swift中，Qos共有六个级别，从高到低依次为:</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.userInteractive  &gt; .unspecified &gt; .<span class="keyword">default</span> &gt; .utility &gt; .background &gt; .unspecified</span><br></pre></td></tr></table></figure>
<h2 id="3-信号量-semaphore"><a href="#3-信号量-semaphore" class="headerlink" title="3.信号量(semaphore)"></a>3.信号量(semaphore)</h2><p>维基百科对于信号量的描述:</p>
<blockquote>
<p>信号量（英语：Semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态.</p>
</blockquote>
<p>来看一段示列代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semaphore</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/// 创建一个数值为0的信号量</span></span><br><span class="line">	<span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</span><br><span class="line">		<span class="comment">/// 信号量+1，有等待的任务这个时候回继续执行</span></span><br><span class="line">		semaphore.signal()</span><br><span class="line">		<span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">			<span class="comment">/// 先判断信号量，如果信号量为0，则等待，否则继续往下执行</span></span><br><span class="line">			semaphore.wait()</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"\(i)"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出的结果是0到10乱序输出，符合第一点里面讲的，并发异步输出是无序的。<br>如果把semaphore.signal()注释掉，这个方法将不会有任何输出，因为semaphore的数值一直是0，.wait()方法一直等待</p>
</blockquote>
<p>如果将代码修改成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semaphore</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</span><br><span class="line">		<span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">			semaphore.wait()</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"\(i)"</span>)</span><br><span class="line">			semaphore.signal()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	semaphore.signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果上跟之前的代码看上去是没有不同的，但是最后的semaphore.signal() 是决定前面的循环执行不执行的关键，相当于，给了一个semaphore的信号，前面的方法才开始执行，看到这里就有一种很熟悉的感觉，跟RxSwift的信号的效果就差不多了。</p>
</blockquote>
<h2 id="4-线程安全与锁🔐"><a href="#4-线程安全与锁🔐" class="headerlink" title="4.线程安全与锁🔐"></a>4.线程安全与锁🔐</h2><h3 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1.线程安全"></a>1.线程安全</h3><ul>
<li>什么是线程安全？</li>
</ul>
<blockquote>
<p>当一段代码被多个线程执行，执行后的结果与多个线程依次执行的结果是一致，那么这段代码就是线程安全的。</p>
</blockquote>
<p>维基百科的描述:</p>
<blockquote>
<p>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
</blockquote>
<p>这里根据以往的经验给出一个总结:</p>
<blockquote>
<p>大多数的Cocoa提供的Api都不是线程安全的，比如UIKit，只能在主线程上操作。</p>
</blockquote>
<p>OC中，不可变对象是线程安全的，可变对象不是线程安全的。</p>
<h3 id="2-锁-Lock-🔐"><a href="#2-锁-Lock-🔐" class="headerlink" title="2.锁(Lock)🔐"></a>2.锁(Lock)🔐</h3><h4 id="1-死锁"><a href="#1-死锁" class="headerlink" title=" 1.死锁 "></a><font color="#DC143C"> 1.死锁 </font></h4><ul>
<li>什么是死锁？</li>
</ul>
<p>维基百科:</p>
<blockquote>
<p>当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。</p>
</blockquote>
<p>在上面任务与队列中提到了<font color="#DC143C"> 4.主队列的同步任务会造成死锁，程序假死 </font>其实这个描述是针对主队列的，更普适的描述应该是:</p>
<blockquote>
<p>在某一个串行队列中(主队列是串行队列)，向该队列添加同步任务，则该队列会死锁。</p>
</blockquote>
<p>根据上述描述可以总结出死锁的必要条件:</p>
<ul>
<li>1.串行队列</li>
<li>2.同步任务</li>
<li>3.向该队列添加</li>
</ul>
<p>下面来看示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"开始"</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"线程死锁了！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"结束"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一个典型的死锁，但是是因为在主队列中执行的，所以其实有点难理解，因为默认的就是主队列。将主队列换成串行队列再来看一下:</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.test.queue"</span>)</span><br><span class="line">queue.async &#123;</span><br><span class="line">	queue.sync &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"线程死锁了！"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的代码不难看出queue是一个串行队列，串行队列(queue)异步(这里可以是同步也可以是异步)执行任务，在这个任务里面再次由串行队列(queue)同步执行任务。串行队列执行第一个任务不管是同步还是异步都是没有问题的，当在串行队列中执行第二个同步任务的时候，执行同步任务的队列会阻塞当前队列等待同步任务执行完成返回后继续执行当前队列，但是由于是在当前队列中执行的同步任务，当前队列在一开始的时候就被阻塞了，所以不会执行</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"线程死锁了！"</span>)</span><br></pre></td></tr></table></figure>
<p>串行队列(queue)在执行这句代码之前就锁死了。在queue队列中，因为要执行同步任务，在进行同步任务的同时queue锁死，而</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.sync &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"线程死锁了！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的任务在等待queue解锁，</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.async &#123;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又在等待同步任务的完成好继续下面的任务，造成了互相等待的过程。所以就造成了死锁。</p>
<p>以上是单独一个队列的死锁，还有多个队列间的循环等待造成的死锁</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue1.sync &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"死锁了！01"</span>)</span><br><span class="line">	queue2.sync &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"死锁了！02"</span>)</span><br><span class="line">		queue1.sync &#123;</span><br><span class="line">			<span class="comment">///</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"死锁了！11"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"死锁了！12"</span>)</span><br></pre></td></tr></table></figure>
<p>以上。</p>
<h4 id="2-互斥锁-NSLock"><a href="#2-互斥锁-NSLock" class="headerlink" title="2.互斥锁(NSLock)"></a>2.互斥锁(NSLock)</h4><ul>
<li>什么是互斥锁？</li>
</ul>
<p>互斥锁的文档:</p>
<blockquote>
<p>An NSLock object is used to coordinate the operation of multiple threads of execution within the same application. An NSLock object can be used to mediate access to an application’s global data or to protect a critical section of code, allowing it to run atomically.</p>
</blockquote>
<p>NSLock继承自NSObject,实现了NSLocking协议，NSLocking定义了两个方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSLocking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来加锁和解锁。</p>
<p>来看以下一段代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">20</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> queue1 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.test.queue1"</span>)</span><br><span class="line">      <span class="keyword">let</span> queue2 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.test.queue2"</span>)</span><br><span class="line">      queue1.async &#123;</span><br><span class="line">          <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;arr.<span class="built_in">count</span> &#123;</span><br><span class="line">              arr[index] = <span class="number">9</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      queue2.async &#123;</span><br><span class="line">          <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;arr.<span class="built_in">count</span> &#123;</span><br><span class="line">              arr[index] = <span class="number">6</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="built_in">print</span>(arr)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这个段代码的print是随机的，6跟9混合，结果不固定。从线程安全来说这段代码是线程不安全的，因为结果不固定。</p>
<p>这里可以使用互斥锁NSLock来使这段代码线程安全:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>()</span><br><span class="line">      <span class="keyword">var</span> arr = [<span class="number">20</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> queue1 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.test.queue1"</span>)</span><br><span class="line">      <span class="keyword">let</span> queue2 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.test.queue2"</span>)</span><br><span class="line">      queue1.async &#123;</span><br><span class="line">          lock.lock()</span><br><span class="line">          <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;arr.<span class="built_in">count</span> &#123;</span><br><span class="line">              arr[index] = <span class="number">9</span></span><br><span class="line">          &#125;</span><br><span class="line">          lock.unlock()</span><br><span class="line">      &#125;</span><br><span class="line">      queue2.async &#123;</span><br><span class="line">          lock.lock()</span><br><span class="line">          <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;arr.<span class="built_in">count</span> &#123;</span><br><span class="line">              arr[index] = <span class="number">6</span></span><br><span class="line">          &#125;</span><br><span class="line">          lock.unlock()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="built_in">print</span>(arr)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码无论执行多少遍，最后的输出都是[6,6,6,6,6,6…,6,6,6]</p>
<p>NSLock在这里的作用是在queue1队列对arr进行操作的时候锁住了arr，其他的队列(串行队列，线程)无法对他进行操作，queue2要对arr进行操作，只能等queue1对arr进行unlock之后才能开始对arr操作，queue2在操作arr的时候，也将arr锁住，保证操作期间的线程安全。</p>
<h4 id="3-递归锁"><a href="#3-递归锁" class="headerlink" title="3.递归锁"></a>3.递归锁</h4><ul>
<li>什么是递归锁？</li>
</ul>
<p>递归锁的文档:</p>
<blockquote>
<p>NSRecursiveLock defines a lock that may be acquired multiple times by the same thread without causing a deadlock, a situation where a thread is permanently blocked waiting for itself to relinquish a lock. While the locking thread has one or more locks, all other threads are prevented from accessing the code protected by the lock.</p>
</blockquote>
<p>NSRecursiveLock定义了一种锁，这种锁能够在同一个线程上多次加锁，而不会引起死锁（一个线程永远的等待自己解锁）。当被锁住的线程有一个或者多个锁的时候，其他线程就不能访问被保护的代码。</p>
<p>递归所是为了解决NSLock在同一个线程上不能多次加锁的问题。代码如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>()</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">          lock.lock()</span><br><span class="line">          lock.lock()</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"死锁~🔐"</span>)</span><br><span class="line">          lock.unlock()</span><br><span class="line">          lock.unlock()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>当NSlock在同一个线程上重复加锁时，会出现死锁，等待自己解锁<br>如果把lock换成NSRecursiveLock，以上代码将正常执行。</p>
<h4 id="4-条件锁"><a href="#4-条件锁" class="headerlink" title="4.条件锁"></a>4.条件锁</h4><p>NSConditionLock条件锁:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSConditionLock</span>(condition: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>condition是Int类型，NSConditionLock也有一个加锁方法和一个解锁方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">(whenCondition condition: Int)</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">(withCondition condition: Int)</span></span></span><br></pre></td></tr></table></figure>
<p>加锁方法:当whenCondition condition与初始化时传入的condition相同是，获取锁对象并立即返回，否则阻塞当前线层直到condition相同。<br>解锁方法:解锁，并设置lock。condition = condittion 代码如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> lock = <span class="type">NSConditionLock</span>(condition: <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="number">20</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> queue1 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.test.queue1"</span>)</span><br><span class="line">        <span class="keyword">let</span> queue2 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.test.queue2"</span>)</span><br><span class="line">        queue1.async &#123;</span><br><span class="line">            lock.lock(whenCondition: <span class="number">10</span>)</span><br><span class="line"><span class="comment">//            for index in 0..&lt;arr.count &#123;</span></span><br><span class="line"><span class="comment">//                arr[index] = 9</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            lock.unlock(withCondition: <span class="number">8</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        queue2.async &#123;</span><br><span class="line">            lock.lock(whenCondition: <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;arr.<span class="built_in">count</span> &#123;</span><br><span class="line">                arr[index] = <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock(withCondition: <span class="number">8</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">print</span>(arr)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在当queue1的whenCondition = 10时，加锁，之后unlock解锁的时候condition变成了8，所以线程queue2的lock.condition = 8时线程不会阻塞，最后输出结果是[6,6,6,…,6,6,6]<br>如果queue1中的whenCondition != 10,那么下面的代码都不会执行，因为不会执行lock.unlock(withCondition: 8),所以queue2.lock也不会执行。</p>
<p>下面有个人对于GCD的一些简单封装:</p>
<p><a href="https://github.com/chuqingr/CHGCD" target="_blank" rel="noopener">GCD封装</a></p>
<p>网上关于线程安全比较深入的文章:</p>
<p><a href="https://objccn.io/issue-2-4/" target="_blank" rel="noopener">线程安全类的设计</a></p>

      
    </div>
    
    
    
    <div>
  
    <div>

    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>

</div>

  
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/swift/" rel="tag"><i class="fa fa-tag"></i> swift</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/06/iOS-App启动时间优化/" rel="next" title="iOS App启动流程">
                <i class="fa fa-chevron-left"></i> iOS App启动流程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/28/iOS项目架构的选择/" rel="prev" title="iOS项目架构的选择">
                iOS项目架构的选择 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2018/08/22/iOS-多线程GCD封装/"
           data-title="iOS 多线程GCD封装" data-url="https://www.chuqingr.cn/2018/08/22/iOS-多线程GCD封装/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yshao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chuqingr" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD技术点"><span class="nav-number">1.</span> <span class="nav-text">GCD技术点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-老生常谈-任务与队列"><span class="nav-number">1.1.</span> <span class="nav-text">1.老生常谈 任务与队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-线程间通讯与服务优先级-Qos"><span class="nav-number">1.2.</span> <span class="nav-text">2.线程间通讯与服务优先级(Qos)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-线程间通讯"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.线程间通讯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-服务优先级-Qos"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.服务优先级(Qos)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-信号量-semaphore"><span class="nav-number">1.3.</span> <span class="nav-text">3.信号量(semaphore)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-线程安全与锁🔐"><span class="nav-number">1.4.</span> <span class="nav-text">4.线程安全与锁🔐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-线程安全"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-锁-Lock-🔐"><span class="nav-number">1.4.2.</span> <span class="nav-text">2.锁(Lock)🔐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-死锁"><span class="nav-number">1.4.2.1.</span> <span class="nav-text"> 1.死锁 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-互斥锁-NSLock"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2.互斥锁(NSLock)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-递归锁"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">3.递归锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-条件锁"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4.条件锁</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yshao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  





  

  

  

  
  

  

  

  

</body>
</html>
